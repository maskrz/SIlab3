/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package view;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import structures.Node;

/**
 *
 * @author Skrzypek
 */
public class ReversiFrame extends javax.swing.JFrame {

    /**
     * Creates new form ReversiFrame
     */
    public int[][] tab;
    int player;
    boolean started;
    boolean pawnAmount;
    boolean moves;
    boolean pawnPositions;

    public ReversiFrame() {
        initComponents();
        tab = new int[8][8];
        tab[3][3] = 1;
        tab[3][4] = -1;
        tab[4][3] = -1;
        tab[4][4] = 1;
        player = 1;
        started = false;
        pawnAmount = true;
        pawnPositions = true;
        moves = true;
        board.addMouseListener(new MouseListener() {

            @Override
            public void mouseClicked(MouseEvent e) {
                if (started) {
                    Point b = e.getPoint();
                    int x = (int) b.getX();
                    int y = (int) b.getY();
                    x /= 70;
                    y /= 70;

                    if (tab[x][y] == 0) {
                        //System.out.println(canSetPawn(x, y, player, tab));
                        boolean[] td = new boolean[8];
                        if (canSetPawn(x, y, player, tab, td)) {
                            setPawn(x, y, player, tab, td);
                            drawBoard();
                            player = (player == 1) ? -1 : 1;
                        }
                        System.out.println(boardRating(tab));
                    }

                }
            }

            @Override
            public void mousePressed(MouseEvent e) {
            }

            @Override
            public void mouseReleased(MouseEvent e) {
            }

            @Override
            public void mouseEntered(MouseEvent e) {
            }

            @Override
            public void mouseExited(MouseEvent e) {
            }
        });
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        board = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        board.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        javax.swing.GroupLayout boardLayout = new javax.swing.GroupLayout(board);
        board.setLayout(boardLayout);
        boardLayout.setHorizontalGroup(
            boardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 558, Short.MAX_VALUE)
        );
        boardLayout.setVerticalGroup(
            boardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 558, Short.MAX_VALUE)
        );

        jButton1.setText("jButton1");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("jButton2");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setText("tree test");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton4.setText("mt test");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(board, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jButton3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(319, 319, 319)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton2)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(153, 153, 153)
                                .addComponent(jButton1)))))
                .addContainerGap(285, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(board, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jButton3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(0, 19, Short.MAX_VALUE)
                                .addComponent(jButton1))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jButton4)
                                .addGap(0, 0, Short.MAX_VALUE))))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jButton2)
                        .addGap(26, 26, 26))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        drawBoard();
        started = true;
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        findBestMove();
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        Node root = new Node(5);
        root.addNode(new Node(5));
        root.addNode(new Node(5));
        Node t = new Node(1);
        root.getChildren().get(0).addNode(t);
        t = new Node(-2);
        root.getChildren().get(0).addNode(t);
        t = new Node(-1);
        root.getChildren().get(0).addNode(t);
        t = new Node(-3);
        root.getChildren().get(1).addNode(t);
        t = new Node(7);
        root.getChildren().get(1).addNode(t);
        root.calcEval();
//        root.getChildren().get(0).calcEval();
        System.out.println(root.getEval());
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        Node root = new Node(0);
        makeTreeLevel(tab, root, player);
        System.out.println(root.getChildren().size());
        root = root.getChildren().get(2);
        makeTreeLevel(tab, root, player);
        System.out.println(root.getChildren().size());
    }//GEN-LAST:event_jButton4ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ReversiFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ReversiFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ReversiFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ReversiFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new ReversiFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel board;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    // End of variables declaration//GEN-END:variables

    private void drawBoard() {
        drawLines();
        drawPawns();
    }

    private void drawLines() {
        int act = 0;
        Graphics g = board.getGraphics();
        for (int i = 0; i < 9; i++) {
            g.drawLine(0, act, 570, act);
            g.drawLine(act, 0, act, 570);
            act += 70;
        }
    }

    private void drawPawns() {
        Graphics g = board.getGraphics();
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (tab[i][j] == 1) {
                    g.setColor(Color.red);
                    g.fillOval(i * 70, j * 70, 70, 70);
                }
                if (tab[i][j] == -1) {
                    g.setColor(Color.blue);
                    g.fillOval(i * 70, j * 70, 70, 70);
                }
            }
        }
    }

    private void setPawn(int x, int y, int p, int[][] t, boolean[] td) {
        t[x][y] = p;
        recalcBoard(x, y, player, t, td);
    }

    private boolean canSetPawn(int x, int y, int p, int[][] t, boolean[] td) {
        boolean result = false;
        if (t[x][y] != 0) {
            return false;
        }
        int cx = x;
        int cy = y;
        int np = (p == 1) ? -1 : 1;

        // lewo
        x--;
        while (x >= 0 && t[x][y] == np) {
            x--;
        }
        x++;
        if (x != cx && x != 0 && t[x - 1][y] == p) {
            result = true;
            td[0] = true;
        }
        x = cx;


        //prawo
        x++;
        while (x < 8 && t[x][y] == np) {
            x++;
        }
        x--;
        if (x != cx && x != 7 && t[x + 1][y] == p) {
            result = true;
            td[1] = true;
        }
        x = cx;


        //gora
        y--;
        while (y >= 0 && t[x][y] == np) {
            y--;
        }
        y++;
        if (y != cy && y != 0 && t[x][y - 1] == p) {
            result = true;
            td[2] = true;
        }
        y = cy;


        //dol
        y++;
        while (y < 8 && t[x][y] == np) {
            y++;
        }
        y--;
        if (y != cy && y != 7 && t[x][y + 1] == p) {
            result = true;
            td[3] = true;
        }
        y = cy;



        //skos1
        x--;
        y--;
        while (x >= 0 && y >= 0 && t[x][y] == np) {
            x--;
            y--;
        }
        x++;
        y++;
        if (x != cx && y != cy && x != 0 && y != 0 && t[x - 1][y - 1] == p) {
            result = true;
            td[4] = true;
        }
        x = cx;
        y = cy;



        //skos2
        x++;
        y++;
        while (x < 8 && y < 8 && t[x][y] == np) {
            x++;
            y++;
        }
        x--;
        y--;
        if (x != cx && y != cy && x != 7 && y != 7 && t[x + 1][y + 1] == p) {
            result = true;
            td[5] = true;
        }
        x = cx;
        y = cy;



        //skos3
        x--;
        y++;
        while (x >= 0 && y < 8 && t[x][y] == np) {
            x--;
            y++;
        }
        x++;
        y--;
        if (x != cx && y != cy && y != 7 && x != 0 && t[x - 1][y + 1] == p) {
            result = true;
            td[6] = true;
        }
        x = cx;
        y = cy;



        //skos4
        x++;
        y--;
        while (x < 8 && y >= 0 && t[x][y] == np) {
            x++;
            y--;
        }
        x--;
        y++;
        if (x != cx && y != cy && x != 7 && y != 0 && t[x + 1][y - 1] == p) {
            result = true;
            td[7] = true;
        }

        return result;
    }

    private void recalcBoard(int x, int y, int player1, int[][] t, boolean[] td) {
        int cx = x;
        int cy = y;
//        for(int i = 0; i < 8; i++) System.out.print(td[i]);
        if (td[0]) {
            x--;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                x--;
            }
            x = cx;
        }

        if (td[1]) {
            x++;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                x++;
            }
            x = cx;
        }

        if (td[2]) {
            y--;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                y--;
            }
            y = cy;
        }

        if (td[3]) {
            y++;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                y++;
            }
            y = cy;
        }

        if (td[4]) {
            x--;
            y--;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                x--;
                y--;
            }
            x = cx;
            y = cy;
        }

        if (td[5]) {
            x++;
            y++;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                x++;
                y++;
            }
            x = cx;
            y = cy;
        }

        if (td[6]) {
            x--;
            y++;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                x--;
                y++;
            }
            x = cx;
            y = cy;
        }

        if (td[7]) {
            x++;
            y--;
            while (t[x][y] != player1) {
                t[x][y] = player1;
                x++;
                y--;
            }
        }

    }

    public int boardRating(int[][] t) {
        int eval = 0;
        int[][] c = t.clone();
        boolean[] td = new boolean[8];
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (moves && canSetPawn(i, j, 1, c, td)) {
                    eval++;
                }
                if (moves && canSetPawn(i, j, -1, c, td)) {
                    eval--;
                }
                if (pawnAmount) {
                    eval += t[i][j] * 3;
                }
                if (pawnPositions && t[i][j] != 0) {
                    int pl = t[i][j];
                    if (i == 0 || i == 7) {
                        if (j == 0 || j == 7) {
                            //rogi
                            eval = eval + (pl * 20);
                        } else if (j == 1 || j == 6) {
                            //przy rogach
                            eval = eval + (pl * (-6));
                        } else {
                            //boki
                            eval = eval + (pl * 8);
                        }
                    } else if (i == 1 || i == 6) {
                        if (j < 2 || j > 5) {
                            //przy rogach
                            eval = eval + (pl * (-6));
                        } else {
                            eval = eval + (pl * (-2));
                        }
                    } else {
                        if (j == 0 || j == 7) {
                            eval = eval + (pl * 8);
                        } else if (j == 1 || j == 6) {
                            eval = eval + (pl * (-2));
                        } else {
                            eval = eval + (pl * 2);
                        }
                    }
                }
            }
        }

        return eval;
    }

    private void findBestMove() {
        int[][] c = copy(tab);
        int[][] evals = new int[64][3];
        int counter = 0;
        boolean[] td = new boolean[8];
//        printTab(c);
//        System.out.println(canSetPawn(5, 3, player, c, td));
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (canSetPawn(i, j, player, c, td)) {
                    setPawn(i, j, player, c, td);
                    recalcBoard(i, j, player, c, td);
                    evals[counter][0] = boardRating(c);
                    evals[counter][1] = i;
                    evals[counter][2] = j;
                    counter++;
                    resetTd(td);
                    c = copy(tab);
                    //System.out.println("jestem "+ i + " "+ j+ " "+player);
                }
            }
        }
        for (int i = 0; i < counter; i++) {
            System.out.println(evals[i][0] + " " + evals[i][1] + " " + evals[i][2]);
        }

    }

    private void makeTreeLevel(int[][] temp, Node n, int pl) {
        int[][] c = copy(temp);
        int counter = 0;
        ArrayList<Node> children = n.getChildren();
        boolean[] td = new boolean[8];
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (canSetPawn(i, j, pl, c, td)) {
                    setPawn(i, j, pl, c, td);
                    recalcBoard(i, j, pl, c, td);
                    Node node = new Node(boardRating(c));
                    children.add(node);
                    counter++;
                    resetTd(td);
                    c = copy(temp);
                    //System.out.println("jestem "+ i + " "+ j+ " "+player);
                }
            }
        }
    }

    public void resetTd(boolean[] td) {
        for (int i = 0; i < 8; i++) {
            td[i] = false;
        }
    }

    public void printTab(int[][] t) {
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                System.out.print(t[i][j] + " ");
            }
            System.out.println("");
        }
    }

    private int[][] copy(int[][] tab) {
        int[][] c = new int[8][8];
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                c[i][j] = tab[i][j];
            }
        }
        return c;
    }
}
